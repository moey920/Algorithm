### 올바른 괄호인지 판단하기

본 문제에서는 입력으로 주어지는 괄호가 올바른 괄호인지를 판단하는 프로그램을 작성합니다.

예를 들어, ‘(())’ 은 올바른 괄호이지만, ‘(()))’, 혹은 ‘(()()(‘ 는 올바른 괄호가 아닙니다.

올바른 괄호일때 ‘YES’를, 올바르지 않은 괄호일때 ‘NO’를 출력해 봅시다.

- 입력
괄호 pp가 주어집니다.

- 출력
pp가 올바른 괄호이면 YES, 그렇지 않으면 NO를 출력합니다.

```
# 1번 카운터 사용하기
from collections import Counter

def checkParen(p):
    # 순서가 틀린경우도 고려해야함
    # if Counter(p)['('] == Counter(p)[')'] :
    #     if p[-1] != "("
    #         return "YES"
    # else :
    #     return "NO"
        
    # 2번 재귀호출 사용하기
    # for로 인접한 두 괄호 씩을 보면서 '(',')' 일 떄 지금 보고 있는 괄호 순서쌍을 빼주고, 나머지 괄호쌍들만 전달
    if p == '' :
        return "YES"

    for i in range(len(p) - 1) :
        if p[i] == '(' and p[i+1] == ')' :
            return checkParen(p[:i] + p[i+2:])
    return "NO"
    # 3번 스택 사용하기

    

def main():
    '''
    Do not change this code
    '''

    x = input()
    print(checkParen(x))

if __name__ == "__main__":
    main()
```

### 이진수 변환
10진수를 2진수로 변환하여 출력하는 프로그램을 작성하세요. 단, 재귀호출을 이용하여 작성합니다.

```
import sys
sys.setrecursionlimit(100000)

def convertBinary(n) :
    '''
    10진수 n을 2진수로 변환하여 반환합니다.

    *주의* : 변환된 2진수는 문자열이어야 합니다.

    예를 들어, 19가 입력될 경우 문자열 "10011"이 반환되어야 합니다.
    
    5 = 1*2^2 + 0*2^1 + 1*2^0 --> 101
    '''
    # 1번 : 내장함수 이용
    # return format(n, 'b')
    
    # 2번 : 재귀함수 이용
    if n == 0:
        return ""
    return convertBinary(n // 2)  + str(n % 2)


def main():
    '''
    이 부분은 수정하지 마세요.
    '''


    n = int(input())

    print(convertBinary(n))

if __name__ == "__main__":
    main()
```

### 이진탐색 알고리즘
이전 시간에 배운 이진탐색 알고리즘을 통해 다음의 문제를 해결해 봅시다.

이미 정렬이 되어 있는 정수로 이루어진 리스트와 특정 정수가 주어질 때, 특정 정수가 정수 리스트의 어느 인덱스에 들어가야 하는지 찾는 프로그램을 작성해 봅시다.
```
def binary_search(nums, num):
    #nums : 주어진 정수들을 담은 리스트
    #num : 내가 찾고싶은 숫자
    start = 0 # 내가 찾고자하는 범위의 제일 왼쪽
    end = len(nums) - 1 # 내가 찾고자하는 범위의 제일 오른쪽
    while start <= end:
        mid = (start + end) // 2
        if nums[mid] == num:
            return mid
        elif nums[mid] > num:
            end = mid - 1
        else: 
            start = mid + 1
        
    return start
    
    



# 4가 출력되어야 합니다.
print(binary_search([1, 2, 4, 6], 7))

# 1이 출력되어야 합니다.
print(binary_search([1, 3, 5, 6], 2))

# 0이 출력되어야 합니다.
print(binary_search([1, 5, 7, 9], 0))
```

### quick sort
입력으로 nn개의 수가 주어지면, quick sort를 구현하는 프로그램을 작성하세요.
```
def quickSort(array):
    '''
    퀵정렬을 통해 오름차순으로 정렬된 array를반환하는 함수를 작성하세요.
    '''
    if len(array) <= 1:
        return array
    pivot = array[0]
    left = [] # pivot 보다 작은수를 담을 리스트
    right = [] # pivot 보다 크거나 같은수를 담을 리스트
    for i in array[1:]:
        if i < pivot:
            left.append(i)
        else:
            right.append(i)
    return quickSort(left) + [pivot] + quickSort(right)

def main():
    line = [int(x) for x in input().split()]

    print(*quickSort(line))

if __name__ == "__main__":
    main()
```

### 합병 정렬 알고리즘 구현하기
이전 시간에는 합병 정렬 알고리즘을 사용하여 주어진 숫자들을 오름차순으로 정렬했습니다.

이번 시간에는 매개변수로 전달된 정수 리스트 nums를 내림차순으로 정렬한 결과를 리스트로 반환하는 mergeSort(nums)를 구현해야 합니다.
```
def mergeSort(nums) :
    # 나누는
    if len(nums) <= 1:
        return nums
    mid = len(nums) // 2
    # print(nums)
    # print('divide!!!')
    left = mergeSort(nums[:mid]) # 정렬된 리스트들
    right = mergeSort(nums[mid:]) # 정렬된 리스트들
    # print(left, right)
    # 합치자!
    sorted_list = merge(left, right) # 정렬된 리스트들을 합쳐준것
    # print('sorted_list :',sorted_list)
    
    return sorted_list

def merge(left, right):
    l = 0
    r = 0
    sorted_list = []
    while l < len(left) and r < len(right):
        if left[l] > right[r]:
            sorted_list.append(left[l])
            l += 1
        else:
            sorted_list.append(right[r])
            r += 1
    while l < len(left):
        sorted_list.append(left[l])
        l += 1
    while r < len(right):
        sorted_list.append(right[r])
        r += 1
    return sorted_list
    
            
# [8, 6, 4, 3, 2, 1]이 출력되어야 합니다.
print(mergeSort([1, 6, 3, 8, 2, 4, 5, 7]))

# [9, 7, 4, 3, 2, 1]가 출력되어야 합니다.
print(mergeSort([7, 2, 4, 1, 9, 3, 1, 3]))
```
