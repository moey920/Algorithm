# 효율성의 측정 방식

- 시간 복잡도 : 코드가 얼마나 빨리 실행되는가(알고리즘에 사용되는 총 연산횟수)
- 공간 복잡도 : 코드가 얼마나 많은 메모리를 사용하는가

## 시간 복잡도 맛보기
```
sum = 0;
for i in [1, 2, 3, 4]:
    sum += i;
```
- 시간 복잡도 = O(N), 1+4 = 5(회)
```
randomNumber = 0 # 1
nums = [1, 2, 3, 4] # 1
for i in range(len(nums)): # 4 
    for j in range(len(nums)): # * 4
        randomNumber += nums[i] * nums[j]
```
- 시간 복잡도 = 1 + 1 + 16 = 18(회), O(N^2)

> 입력 변수의 크기가 N 이라면?
- 코드의 시간 복잡도 = f(N), N에 대한 함수

## N에 대한 복잡도
```
def doNothing(nums):
    return nums # 1
```
- 시간 복잡도 = 1

```
def doSomething(nums):
    sum = 0 # 1
    for num in nums: # nums(N) 만큼 실행
        sum += num
    return sum # 1
```
- 시간 복잡도 = N + 2

```
def doManything(nums):
    allPairs = [] # 1
    for i in range(len(nums)): # N
        for j in range(len(nums)): # N^2
            if nums[i] < nums[j]: # 둘 중 하나는 무조건 실행된다. 조건문 1 + if,else 중 하나 1 = 2
                allPairs.append((nums[i], nums[j]))
            else:
                allPairs.append((nums[i], nums[j]))
    return allPairs # 1
```
- 시간 복잡도 = 2 × N^2 + 2

# Big-O 시간 복잡도란?

> Big-O = 시간복잡도 함수의 가장 높은 **차수**
- 계수는 고려하지 않는다.

- aN + b = O(N)
- aNlogN + b = O(NlogN)
- aN2 + bN + c = O(N2)

```
def doNothing(nums):
    return nums
```
- 시간 복잡도 = 1 / Big-O 시간 복잡도 = O(1)
- N의 크기에 관계없이 일정한 경우(상수항)은 O(1)로 표기한다.

```
def doSomething(nums):
    sum = 0
    for num in nums:
        sum += num
    return sum
```
시간 복잡도 = N + 2 / Big-O 시간 복잡도 = O(N)

```
def doManything(nums):
    allPairs = [] # 1
    for i in range(len(nums)): # N
        for j in range(len(nums)): # N^2
            if nums[i] < nums[j]: # 둘 중 하나는 무조건 실행된다. 조건문 1 + if,else 중 하나 1 = 2
                allPairs.append((nums[i], nums[j]))
            else:
                allPairs.append((nums[i], nums[j]))
    return allPairs # 1
```
- 시간 복잡도 = 2×N2 + 2 / Big-O 시간 복잡도 = O(N^2)

### 복잡도의 중요성?
Big-O 시간 복잡도 계산법칙 1
for i in range(len(nums)):
for j in range(len(nums)):
for i in range(len(nums)):
for j in range(len(nums)):
for k in range(len(nums)):
for num in nums:
For / while loop가 한 번 중첩될 때마다 O(N)
Big-O 시간 복잡도 계산법칙 2
nums = [2, 8, 19, 37, 4, 5]
if num in nums:
nums.sort()
nums = {2, 8, 19, 37, 4, 5}
if num in nums:
자료구조 사용, 다른 함수 호출에는 각각의 O(N)을 파악
Big-O 시간 복잡도 계산법칙 3
1 2 3 5 8 6 0 4
8 6 0 4
8 6
6
↓
↓
↓
이진 탐색
N = 8
실행 횟수 = log(8) = 3
매번 절반씩 입력값이 줄어들면 O(logN)
공간 복잡도
알고리즘에 사용되는
메모리 공간의 총량
공간 복잡도 계산하기
a = 1
Big-O 공간 복잡도 = 
공간 복잡도 계산하기
a = [num for num in nums]
Big-O 공간 복잡도 = 
공간 복잡도 계산하기
a = [[num for num in nums] for num in nums]
Big-O 공간 복잡도 = 
<킲킃>
 핂솧킪�믾
배열
배열
배열의 공간 복잡도 = O(N)
nums = [1, 2, 3, 4, 5, 6]
가장 기본적인 자료 구조
배열 : Big-O 시간 복잡도
nums = [1, 2, 3, 4, 5, 6]
nums[2]
인덱스를 알 때 : O(1)
배열 : Big-O 시간 복잡도
nums = [1, 2, 3, 4, 5, 6]
if 5 in nums:
인덱스를 모를 때 = 하나씩 검사 : O(N)
배열 : Big-O 시간 복잡도
nums = [1, 2, 3, 4, 5, 6]
for num in nums:
배열 전부 순회하기 : O(N)
배열 : Big-O 시간 복잡도
nums = [1, 2, 3, 4, 5, 6]
nums.append(7)
자료 끝에 추가하기 : O(1)
배열 : Big-O 시간 복잡도
nums = [1, 2, 3, 4, 5, 6]
nums.insert(3, 9)
자료 중간에 추가하기 : O(N)
배열 인덱싱
nums[2]
nums[2:5]
nums[len(nums)-1]
nums[-1]
문자열
tempString = “abcdef”
for ch in tempString:
배열의 한 종류, 문자들의 배열
2차원 배열
nums = [[1, 2, 3, 4, 5]\
[6, 7, 8, 9, 10]\
[11, 12, 13, 14, 15]\
[16, 17, 18, 19, 20]]
<킲킃>
짾폂픦 헒
해쉬
해쉬
studentIds = {
“박지나”:123,
“송호준”:145,
“이주원”:563 }
“박지나” 123
“송호준” 145
“이주원” 563
… …
Dictionary.Key + Value (in Python)
Key는 중복될 수 없음
공간 복잡도는 대략 O(N)
해쉬 : Big-O 시간 복잡도
print(studentIds[“박지나”])
Key를 이용해서 Value 가져오기 : 대략 O(1)
해쉬 : Big-O 시간 복잡도
if(“박지나” in studentIds):
if(“손지윤” in studnetIds):
Key가 존재하는지 확인하기 : 대략 O(1)
해쉬 : Big-O 시간 복잡도
studentIds[“손지윤”] = 938
Key, Value 추가하기 : 대략 O(1)
해쉬 : Big-O 시간 복잡도
studentIds[“박지나”] = 555
해당 Key의 Value 변경하기 : 대략 O(1)
해쉬 : 공간 복잡도
해쉬의 공간 복잡도 = O(N)
해쉬는 데이터가 입력되지 않은
여유 공간이 많아야 성능 유지
Set
“박지나”
“송호준”
“이주원”
“손지윤”
studentNames = {“박지나”, “송호준”, “이주원”, “손지윤”}
Value 없이 Key만 있는 Dictionary
<킲킃>
팒빦믆앶 �힎
배열과 해쉬의 trade-off
배열 VS 해쉬
해쉬
식별자가 있는 데이터, 시간 복잡도↓/ 공간 복잡도↑
배열
식별자가 없는 데이터, 시간 복잡도↑/ 공간 복잡도↓
